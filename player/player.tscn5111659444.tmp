[gd_scene load_steps=5 format=3 uid="uid://ce10gkdeiprj7"]

[ext_resource type="PackedScene" uid="uid://bc7nsyavco5xh" path="res://spell_casting/spellcast.tscn" id="2_rkbax"]
[ext_resource type="PackedScene" uid="uid://ds6ehm1oneoe7" path="res://player/interact.tscn" id="3_g1dw6"]

[sub_resource type="GDScript" id="GDScript_rkbax"]
script/source = "extends Node3D
class_name Player

const MOVE_SIGIL = preload(\"uid://iw7wpmqsi86\")

@onready var camera: Camera3D = %Camera3D
@onready var neck: Node3D = %Neck
@onready var player_collision: Area3D = %PlayerCollision

@export var camera_raycast_distance:= 200.0
@export var camera_speed:= 50
@export var spawn_pos:= Vector3(0, 0, 0)
@export_range(1, 3) var movement_speed:= 4

@export var click_to_capture_mouse:= false

var move_to_cell_indicator: Node3D

var tilt_lower_limit:= deg_to_rad(-90)
var tilt_upper_limit:= deg_to_rad(90)

var current_looked_at_cell: Cell
var is_moving:= false

## Stats
var max_hp:= 100.0:
	set(value):
		max_hp = clampf(value, 1.0, 9999.9)

var hp:= max_hp:
	set(value):
		hp = clampf(value, 0.0, max_hp)


func _ready() -> void:
	if click_to_capture_mouse == false:
		Input.mouse_mode = Input.MOUSE_MODE_CAPTURED
	
	position = spawn_pos
	move_to_cell_indicator = get_tree().get_first_node_in_group(\"move_to_cell_indicator\")
	player_collision.area_entered.connect(on_player_collision_area_entered)
	
	await get_tree().create_timer(0.0).timeout
	update_looked_at_cell()
	Bus.player_moved.emit()


func _unhandled_input(event: InputEvent) -> void:
	var mouse_input = event is InputEventMouseMotion and Input.mouse_mode == Input.MOUSE_MODE_CAPTURED
	
	if mouse_input:
		camera_movement(event)
		update_looked_at_cell()


func _input(event: InputEvent) -> void:
	if event.is_action_pressed(\"forward\") and is_moving == false:
		move_forward()
	
	if event.is_action_pressed(\"ui_cancel\"):
		if click_to_capture_mouse == false:
			get_tree().quit()
		
		if click_to_capture_mouse == true:
			Input.mouse_mode = Input.MOUSE_MODE_VISIBLE
	
	if (event.is_action_pressed(\"cast\") or event.is_action_pressed(\"interact\") or event.is_action_pressed(\"forward\")) and click_to_capture_mouse == true:
		Input.mouse_mode = Input.MOUSE_MODE_CAPTURED


func camera_movement(event: InputEvent):
	if not Input.mouse_mode == Input.MOUSE_MODE_CAPTURED:
		return
	
	if not event is InputEventMouseMotion:
		return
	
	neck.rotate_y(-event.relative.x * (camera_speed / 12000.0))
	camera.rotate_x(-event.relative.y * (camera_speed / 12000.0))
	camera.rotation.x = clampf(camera.rotation.x, deg_to_rad(-90), deg_to_rad(90))


func take_damage(amount: float):
	hp -= amount
	Bus.player_lost_hp.emit()


func move_forward():
	if Bgm.check_accuracy() == \"missed\":
		return
	
	update_looked_at_cell()
	
	if current_looked_at_cell == null:
		return
	
	for occupant in current_looked_at_cell.occupants:
		if is_instance_valid(occupant):
			if \"impassable\" in occupant:
				return
	
	var move_speed: float = Bgm.rhythm_notifier.bpm / (movement_speed * 100)
	
	if not Vars.last_activated_circle == null:
		Vars.last_activated_circle.texture = MOVE_SIGIL
	
	var tween:= get_tree().create_tween()
	tween.tween_property(self, \"global_position\", current_looked_at_cell.global_position, move_speed)
	
	tween.play()
	is_moving = true
	tween.tween_callback(update_looked_at_cell)
	tween.tween_callback(set_moving_false)
	tween.tween_callback(Bus.player_moved.emit)


func set_moving_false():
	is_moving = false


func update_looked_at_cell():
	var cell: Area3D = check_raycast_cells()
	
	if not cell is CellCollision:
		return
	
	current_looked_at_cell = cell.get_parent()
	
	move_to_cell_indicator.global_position = cell.global_position
	move_to_cell_indicator.global_rotation_degrees.y = snapped(neck.global_rotation_degrees.y, 90)


func check_raycast_cells():
	var space_state:= camera.get_world_3d().direct_space_state
	##!! middle of screen is dependent on the viewport scale settings
	var middle_of_screen = get_viewport().size / 4
	var origin:= camera.project_ray_origin(middle_of_screen)
	var end:= origin + camera.project_ray_normal(middle_of_screen) * camera_raycast_distance
	var query:= PhysicsRayQueryParameters3D.create(origin, end)
	
	query.collide_with_areas = true
	
	var result:= space_state.intersect_ray(query)
	
	if not \"collider\" in result:
		return
		
	return result[\"collider\"]


func get_look_at_direction():
	var middle_of_screen = get_viewport().size / 4
	return camera.project_ray_normal(middle_of_screen) * camera_raycast_distance


func on_player_collision_area_entered(area: Area3D):
	if \"damage\" in area.owner:
		take_damage(area.owner.damage)
	
	if \"body_damage\" in area.owner:
		take_damage(area.owner.body_damage)
"

[sub_resource type="CylinderShape3D" id="CylinderShape3D_g1dw6"]
height = 2.209961
radius = 0.3

[node name="Player" type="Node3D" groups=["player"]]
script = SubResource("GDScript_rkbax")

[node name="Spellcast" parent="." instance=ExtResource("2_rkbax")]

[node name="Interact" parent="." instance=ExtResource("3_g1dw6")]

[node name="Neck" type="Node3D" parent="."]
unique_name_in_owner = true
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.7422652, 0)

[node name="Camera3D" type="Camera3D" parent="Neck"]
unique_name_in_owner = true
current = true

[node name="OmniLight3D" type="OmniLight3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.282909, 0)
light_color = Color(1, 0.8320722, 0.71004725, 1)
light_volumetric_fog_energy = 1.495
shadow_enabled = true

[node name="PlayerCollision" type="Area3D" parent="." groups=["player_collision"]]
unique_name_in_owner = true
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0)
collision_layer = 8
collision_mask = 36

[node name="CollisionShape3D" type="CollisionShape3D" parent="PlayerCollision"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.10498047, 0)
shape = SubResource("CylinderShape3D_g1dw6")
